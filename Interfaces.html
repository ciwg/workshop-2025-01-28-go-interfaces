<!DOCTYPE html>
<html>
<head>
    <title>Interfaces in Go</title>
</head>
<body>
    <textarea id="source">

class: center, middle

# Interfaces in Go

---

## Workshop Overview

### What We'll Cover:

1. **Structs**: The foundation for defining data in Go.
2. **Embedding**: How to reuse and extend structs.
3. **Interfaces**: The power of abstraction and polymorphism in Go.


---

## What is a Struct?

- **Structs** are custom data types in Go.
- They group related fields together.

### Example:
```go
// GenericEmployee struct
type GenericEmployee struct {
    FullName             string
    EmailAddress         string
    WeeksWorkedAtCompany int
    HoursWorkedPerWeek   int
}
```
- **Fields**: Define the properties of a struct.
- Used to represent real-world objects (e.g., employees).

---

## What is Embedding?

- Embedding lets one struct **includes** fields and methods of another.
- Promotes **code reuse** and avoids duplication.

### Example:
```go
// Maker struct embeds GenericEmployee
type Maker struct {
    GenericEmployee
    ProjectsWorkedOn []string
}
```
- `Maker` can access `FullName`, `EmailAddress`, etc., from `GenericEmployee`.
- Enables **composition instead of inheritance**.

---

## Why Interfaces?

- **Interfaces** define a set of methods that must be implemented.
- Allow different types to share common behavior.
- Enable **polymorphism**: Write code that works with different types.

### Example:
```go
// Employee interface
type Employee interface {
    Name() string
    Email() string
    WorkDetails() (int, int)
    Skills() []string
}
```
- Any struct implementing these methods is an `Employee`.

---

## Implementing Interfaces

### Example: GenericEmployee

```go
func (g GenericEmployee) Name() string {
    return g.FullName
}

func (g GenericEmployee) Email() string {
    return g.EmailAddress
}

func (g GenericEmployee) WorkDetails() (int, int) {
    return g.WeeksWorkedAtCompany, g.HoursWorkedPerWeek
}

func (g GenericEmployee) Skills() []string {
    return []string{} // Placeholder
}
```
- `GenericEmployee` satisfies the `Employee` interface.

---

## Example: Specialized Structs

### Writer
```go
type Writer struct {
    GenericEmployee
    GenresWritten []string
}

func (w Writer) Skills() []string {
    return w.GenresWritten
}
```
### Maker
```go
type Maker struct {
    GenericEmployee
    ProjectsWorkedOn []string
}

func (m Maker) Skills() []string {
    return m.ProjectsWorkedOn
}
```
- Each struct customizes the `Skills()` method.

---

## Reusing Code with Interfaces

### Example: PrintEmployeeDetails
```go
func PrintEmployeeDetails(e Employee) {
    fmt.Printf("Name: %s\n", e.Name())
    fmt.Printf("Email: %s\n", e.Email())
    weeks, hours := e.WorkDetails()
    fmt.Printf("Worked for %d weeks, %d hours per week\n", weeks, hours)
    fmt.Printf("Skills: %v\n\n", e.Skills())
}
```
- Takes any `Employee`.
- Works for `Writer`, `Maker`, or any struct implementing `Employee`.

---

## Polymorphism in Action

### Example: MostSenior Employee
```go
func MostSenior(eList []Employee) Employee {
    mostSenior := eList[0]
    mostSeniorWeeks, _ := mostSenior.WorkDetails()
    for _, e := range eList {
        weeks, _ := e.WorkDetails()
        if weeks > mostSeniorWeeks {
            mostSenior = e
            mostSeniorWeeks = weeks
        }
    }
    return mostSenior
}
```
- Finds the employee with the most weeks worked.
- Works for any type implementing the `Employee` interface.

---

## Real-World Analogy

- Think of `Employee` as a **job description**:
  - Requires specific tasks (methods).
- A `Writer` or `Maker` is like a person in that role:
  - Implements the tasks (methods).
- **Flexibility**: Different roles, same expectations.

---

## Key Takeaways

1. **Structs**: Define real-world objects.
2. **Embedding**: Reuse and extend functionality.
3. **Interfaces**: Enable abstraction and polymorphism.


---

## Grid-POC & Interfaces

- **Grid-POC** relies on modular components to function efficiently.
- **Interfaces** allow us to define common behavior for different implementations.
- **Merkle-DAG & Hash Chains**: Interfaces enable flexible interaction with these structures.

### Example:
```go
type HashStorage interface {
    StoreHash(data []byte) string
    RetrieveHash(hash string) ([]byte, error)
}
```
- This allows us to swap in different **storage backends** without changing core logic.

---

## Testing with Interfaces

- Using **interfaces** allows us to mock dependencies for testing.
- Mocks let us verify behavior **without real API calls**.

### Example:
```go
type MockStorage struct{}

func (m MockStorage) StoreHash(data []byte) string {
    return "mocked-hash"
}

func (m MockStorage) RetrieveHash(hash string) ([]byte, error) {
    return []byte("mocked-data"), nil
}
```
- Helps in writing **isolated, reliable unit tests**.

---

## Real-World Use Cases

- **PromiseGrid**: Uses a **library of hashes** â†’ perfect for an interface-based design.
- **IoT & Makerspace Management**: Standardized API interfaces improve device interoperability.
- **Blockchain-Based Storage**: Interfaces abstract storage logic for different backends.

### Example: Distributed File Interface
```go
type DistributedFile interface {
    Store(data []byte) (string, error)
    Retrieve(hash string) ([]byte, error)
}
```
- Works for **IPFS, blockchain storage, or cloud-based solutions**.

---


## Thank You!

Questions?  

**Repo**: [Workshop Interfaces GitHub](https://github.com/ciwg/workshop-2025-01-28-go-interfaces).
   </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script>
        var slideshow = remark.create();
    </script>
</body>
</html>
